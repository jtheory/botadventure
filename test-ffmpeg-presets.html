<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FFmpeg Preset Tester</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }

        h1 {
            color: #00bfff;
            margin-bottom: 20px;
            text-align: center;
        }

        .controls {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .file-inputs {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .file-input {
            flex: 1;
        }

        .file-input label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 14px;
        }

        .file-input input[type="file"] {
            width: 100%;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .preset-card {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            position: relative;
            transition: all 0.3s;
        }

        .preset-card:hover {
            border-color: #00bfff;
            transform: translateY(-2px);
        }

        .preset-card.running {
            border-color: #ff8800;
            background: #2a2a1a;
        }

        .preset-card.success {
            border-color: #00ff00;
            background: #1a2a1a;
        }

        .preset-card.error {
            border-color: #ff0000;
            background: #2a1a1a;
        }

        .preset-name {
            font-weight: bold;
            color: #00bfff;
            margin-bottom: 5px;
        }

        .preset-description {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 10px;
        }

        .preset-button {
            width: 100%;
            padding: 8px;
            background: #00bfff;
            border: none;
            border-radius: 4px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }

        .preset-button:hover:not(:disabled) {
            background: #0099cc;
        }

        .preset-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .preset-result {
            margin-top: 10px;
            font-size: 12px;
        }

        .preset-video {
            width: 100%;
            margin-top: 10px;
            border-radius: 4px;
        }

        .stats {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            font-size: 11px;
        }

        .stat {
            background: #1a1a1a;
            padding: 4px 8px;
            border-radius: 3px;
        }

        .log-container {
            background: #000;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .log-line {
            margin-bottom: 2px;
            white-space: pre-wrap;
        }

        .log-error { color: #ff6666; }
        .log-success { color: #66ff66; }
        .log-info { color: #6666ff; }
        .log-warning { color: #ffff66; }

        .batch-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .batch-button {
            padding: 10px 20px;
            background: #6c757d;
            border: none;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }

        .batch-button:hover {
            background: #5a6268;
        }

        .loading-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #00bfff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .comparison-table {
            width: 100%;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #444;
        }

        th {
            color: #00bfff;
            font-weight: bold;
        }

        .best { color: #00ff00; }
        .worst { color: #ff6666; }
    </style>
</head>
<body>
    <h1>üé¨ FFmpeg Preset Tester</h1>

    <div style="max-width: 800px; margin: 0 auto 20px; padding: 15px; background: #2a2a2a; border: 1px solid #00bfff; border-radius: 8px; color: #aaa; text-align: center;">
        <strong style="color: #00bfff;">Testing Fast Presets Only</strong><br>
        Showing only viable options for production use. Slow presets (simple, copyAudio, etc.) are hidden.
    </div>

    <div class="controls">
        <div class="file-inputs">
            <div class="file-input">
                <label for="audioFile">Audio File (Required)</label>
                <input type="file" id="audioFile" accept="audio/*">
            </div>
            <div class="file-input">
                <label for="imageFile">Image File (Optional - black background if not provided)</label>
                <input type="file" id="imageFile" accept="image/*">
            </div>
        </div>

        <details style="margin-top: 15px; padding: 10px; background: #1a1a1a; border: 1px solid #444; border-radius: 4px;">
            <summary style="cursor: pointer; color: #00bfff; font-weight: bold;">
                ‚öôÔ∏è Advanced Options
                <span id="settingsStatus" style="font-size: 12px; margin-left: 10px; color: #00ff00;">‚úì Using Production Settings</span>
            </summary>

            <div style="margin-top: 10px; margin-bottom: 15px; padding: 10px; background: #2a2a2a; border-radius: 4px;">
                <h4 style="margin: 0 0 10px 0; color: #00bfff; font-size: 14px;">
                    Still Image Encoding
                    <small style="font-weight: normal; color: #888; font-size: 11px;">(from STILL_IMAGE_SETTINGS)</small>
                </h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div>
                        <label for="framerate" style="display: block; margin-bottom: 5px; font-size: 13px;">
                            Framerate: <span id="framerateValue">1</span> fps
                        </label>
                        <input type="range" id="framerate" min="0.1" max="5" step="0.1" value="1"
                               style="width: 100%;" oninput="document.getElementById('framerateValue').textContent = this.value">
                        <small style="color: #888; font-size: 11px;">Lower = faster encoding, smaller files</small>
                    </div>
                    <div>
                        <label for="gopSize" style="display: block; margin-bottom: 5px; font-size: 13px;">
                            GOP Size: <span id="gopSizeValue">250</span>
                        </label>
                        <input type="range" id="gopSize" min="30" max="9999" step="1" value="250"
                               style="width: 100%;" oninput="document.getElementById('gopSizeValue').textContent = this.value">
                        <small style="color: #888; font-size: 11px;">Larger = smaller files (for still images)</small>
                    </div>
                    <div>
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 13px;">
                            <input type="checkbox" id="tuneStillImage" style="width: auto;">
                            Use -tune stillimage
                        </label>
                        <small style="color: #888; font-size: 11px;">Optimize encoder for still images</small>
                    </div>
                    <div>
                        <label for="threads" style="display: block; margin-bottom: 5px; font-size: 13px;">
                            Threads: <span id="threadsValue">auto</span>
                        </label>
                        <input type="range" id="threads" min="0" max="8" step="1" value="0"
                               style="width: 100%;" oninput="document.getElementById('threadsValue').textContent = this.value === '0' ? 'auto' : this.value">
                        <small style="color: #888; font-size: 11px;">0 = auto, higher = faster (if cores available)</small>
                    </div>
                </div>
            </div>

            <div style="padding: 10px; background: #2a2a2a; border-radius: 4px;">
                <h4 style="margin: 0 0 10px 0; color: #00bfff; font-size: 14px;">Waveform Visualization</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div>
                        <label for="waveformFps" style="display: block; margin-bottom: 5px; font-size: 13px;">
                            Waveform FPS: <span id="waveformFpsValue">10</span>
                        </label>
                        <input type="range" id="waveformFps" min="5" max="30" step="1" value="10"
                               style="width: 100%;" oninput="document.getElementById('waveformFpsValue').textContent = this.value">
                        <small style="color: #888; font-size: 11px;">Animation smoothness vs encoding time</small>
                    </div>
                    <div>
                        <label for="barWidth" style="display: block; margin-bottom: 5px; font-size: 13px;">
                            Bar Width: <span id="barWidthValue">4</span>px
                        </label>
                        <input type="range" id="barWidth" min="1" max="10" step="1" value="4"
                               style="width: 100%;" oninput="document.getElementById('barWidthValue').textContent = this.value">
                        <small style="color: #888; font-size: 11px;">Waveform bar thickness</small>
                    </div>
                </div>
            </div>
        </details>

        <div class="batch-controls">
            <button class="batch-button" onclick="runAllTests()">üöÄ Run All Tests</button>
            <button class="batch-button" onclick="clearResults()">üóëÔ∏è Clear Results</button>
            <button class="batch-button" onclick="downloadComparison()">üìä Download Comparison</button>
        </div>
    </div>

    <div class="preset-grid" id="presetGrid">
        <!-- Preset cards will be generated here -->
    </div>

    <div class="comparison-table" id="comparisonTable" style="display: none;">
        <h3>üìä Comparison Results</h3>
        <table id="resultsTable">
            <thead>
                <tr>
                    <th>Preset</th>
                    <th>File Size</th>
                    <th>Video Duration</th>
                    <th>Generation Time</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody id="resultsBody">
            </tbody>
        </table>
    </div>

    <div class="log-container" id="logContainer">
        <div id="log"></div>
    </div>

    <script type="module">
        // We need to import the compiled JavaScript, not TypeScript
        // During dev, Vite will handle the transformation
        const ffmpegModule = await import('/src/utils/ffmpegCore.ts');
        const { getFFmpeg, runConversion, runTwoPassConversion, conversionPresets, probeFile, createVideoFromFrames, STILL_IMAGE_SETTINGS, WAVEFORM_SETTINGS } = ffmpegModule;

        const visualizerModule = await import('/src/utils/audioVisualizer.ts');
        const { generateWaveformFrames } = visualizerModule;

        // Log production settings on load
        console.log('üìã Production Settings:', { STILL_IMAGE_SETTINGS, WAVEFORM_SETTINGS });

        // Add waveform preset to the list
        conversionPresets.waveform = {
            name: 'Waveform Visualization',
            description: 'Animated waveform with playhead (like the app uses)',
            getCommand: () => [] // Special handling below
        };

        (function() {

        const logEl = document.getElementById('log');
        const presetGrid = document.getElementById('presetGrid');
        const results = {};
        let audioFile = null;
        let imageFile = null;

        function log(msg, type = '') {
            console.log(msg);
            const timestamp = new Date().toTimeString().slice(0, 8);
            const className = type ? `log-${type}` : '';
            logEl.innerHTML += `<div class="log-line ${className}">${timestamp} ${msg}</div>`;
            logEl.parentElement.scrollTop = logEl.parentElement.scrollHeight;
        }

        // File input handlers
        document.getElementById('audioFile').addEventListener('change', (e) => {
            audioFile = e.target.files[0];
            if (audioFile) {
                log(`Audio loaded: ${audioFile.name} (${(audioFile.size / 1024).toFixed(2)} KB)`, 'info');
            }
        });

        document.getElementById('imageFile').addEventListener('change', (e) => {
            imageFile = e.target.files[0];
            if (imageFile) {
                log(`Image loaded: ${imageFile.name} (${(imageFile.size / 1024).toFixed(2)} KB)`, 'info');
            }
        });

        // Initialize controls with production defaults
        function initializeControls() {
            document.getElementById('framerate').value = STILL_IMAGE_SETTINGS.framerate;
            document.getElementById('framerateValue').textContent = STILL_IMAGE_SETTINGS.framerate;
            document.getElementById('gopSize').value = STILL_IMAGE_SETTINGS.gopSize;
            document.getElementById('gopSizeValue').textContent = STILL_IMAGE_SETTINGS.gopSize;
            document.getElementById('tuneStillImage').checked = STILL_IMAGE_SETTINGS.tuneStillImage;
            document.getElementById('threads').value = STILL_IMAGE_SETTINGS.threads;
            document.getElementById('threadsValue').textContent = STILL_IMAGE_SETTINGS.threads === 0 ? 'auto' : STILL_IMAGE_SETTINGS.threads;

            document.getElementById('waveformFps').value = WAVEFORM_SETTINGS.fps;
            document.getElementById('waveformFpsValue').textContent = WAVEFORM_SETTINGS.fps;
            document.getElementById('barWidth').value = WAVEFORM_SETTINGS.barWidth;
            document.getElementById('barWidthValue').textContent = WAVEFORM_SETTINGS.barWidth;
        }

        // Check if current settings match production
        function updateSettingsStatus() {
            const framerate = parseFloat(document.getElementById('framerate').value);
            const gopSize = parseInt(document.getElementById('gopSize').value);
            const tuneStillImage = document.getElementById('tuneStillImage').checked;
            const threads = parseInt(document.getElementById('threads').value);
            const waveformFps = parseInt(document.getElementById('waveformFps').value);
            const barWidth = parseInt(document.getElementById('barWidth').value);

            const matchesStillImage = framerate === STILL_IMAGE_SETTINGS.framerate &&
                                     gopSize === STILL_IMAGE_SETTINGS.gopSize &&
                                     tuneStillImage === STILL_IMAGE_SETTINGS.tuneStillImage &&
                                     threads === STILL_IMAGE_SETTINGS.threads;

            const matchesWaveform = waveformFps === WAVEFORM_SETTINGS.fps &&
                                   barWidth === WAVEFORM_SETTINGS.barWidth;

            const statusEl = document.getElementById('settingsStatus');
            if (matchesStillImage && matchesWaveform) {
                statusEl.textContent = '‚úì Using Production Settings';
                statusEl.style.color = '#00ff00';
            } else {
                statusEl.textContent = '‚ö† Custom Settings (not production)';
                statusEl.style.color = '#ff8800';
            }
        }

        // Create preset cards
        function createPresetCards() {
            // Only show fast/viable presets - filter out the slow ones
            const viablePresets = ['production', 'balanced', 'compressed', 'waveform'];

            for (const [key, preset] of Object.entries(conversionPresets)) {
                // Skip slow presets
                if (!viablePresets.includes(key)) {
                    continue;
                }

                const card = document.createElement('div');
                card.className = 'preset-card';
                card.id = `preset-${key}`;
                card.innerHTML = `
                    <div class="preset-name">${preset.name}</div>
                    <div class="preset-description">${preset.description}</div>
                    <button class="preset-button" onclick="window.runPreset('${key}')">
                        Test This Preset
                    </button>
                    <div class="preset-result" id="result-${key}"></div>
                `;
                presetGrid.appendChild(card);
            }
        }

        // Apply advanced options to a preset
        function applyAdvancedOptions(preset) {
            const framerate = parseFloat(document.getElementById('framerate').value);
            const gopSize = parseInt(document.getElementById('gopSize').value);
            const tuneStillImage = document.getElementById('tuneStillImage').checked;
            const threads = parseInt(document.getElementById('threads').value);

            // Clone the preset to avoid modifying the original
            const modifiedPreset = {
                ...preset,
                getCommand: (inputs) => {
                    const baseCommand = preset.getCommand(inputs);
                    const newCommand = [...baseCommand];

                    // Replace framerate if it exists in the command
                    const framerateIndex = newCommand.indexOf('-framerate');
                    if (framerateIndex !== -1 && framerate !== 1) {
                        newCommand[framerateIndex + 1] = framerate.toString();
                    }

                    // Find the preset parameter and insert tune/GOP/threads after it
                    const presetIndex = newCommand.indexOf('-preset');
                    if (presetIndex !== -1) {
                        let insertIndex = presetIndex + 2; // After preset value

                        // Add tune stillimage
                        if (tuneStillImage) {
                            newCommand.splice(insertIndex, 0, '-tune', 'stillimage');
                            insertIndex += 2;
                        }

                        // Add GOP size
                        if (gopSize !== 250) {
                            newCommand.splice(insertIndex, 0, '-g', gopSize.toString());
                            insertIndex += 2;
                        }

                        // Add threads
                        if (threads !== 0) {
                            newCommand.splice(insertIndex, 0, '-threads', threads.toString());
                        }
                    }

                    return newCommand;
                }
            };

            return modifiedPreset;
        }

        // Run a single preset
        window.runPreset = async function(presetKey) {
            if (!audioFile) {
                alert('Please select an audio file first');
                return;
            }

            const basePreset = conversionPresets[presetKey];
            const preset = applyAdvancedOptions(basePreset);
            const card = document.getElementById(`preset-${presetKey}`);
            const resultDiv = document.getElementById(`result-${presetKey}`);
            const button = card.querySelector('.preset-button');

            // Update UI
            card.className = 'preset-card running';
            button.disabled = true;
            button.innerHTML = 'Converting... <span class="loading-spinner"></span>';
            resultDiv.innerHTML = '';

            const startTime = Date.now();

            // Log advanced settings if any are non-default
            const advSettings = [];
            const framerate = parseFloat(document.getElementById('framerate').value);
            const gopSize = parseInt(document.getElementById('gopSize').value);
            const tuneStillImage = document.getElementById('tuneStillImage').checked;
            const threads = parseInt(document.getElementById('threads').value);
            const waveformFps = parseInt(document.getElementById('waveformFps').value);
            const barWidth = parseInt(document.getElementById('barWidth').value);

            if (presetKey === 'waveform') {
                // Log waveform-specific settings
                if (waveformFps !== 10) advSettings.push(`fps=${waveformFps}`);
                if (barWidth !== 4) advSettings.push(`barWidth=${barWidth}px`);
            } else {
                // Log still image encoding settings
                if (framerate !== 1) advSettings.push(`framerate=${framerate}`);
                if (gopSize !== 250) advSettings.push(`gop=${gopSize}`);
                if (tuneStillImage) advSettings.push('tune=stillimage');
                if (threads !== 0) advSettings.push(`threads=${threads}`);
            }

            log(`\n=== Testing ${basePreset.name} ===`, 'info');
            if (advSettings.length > 0) {
                log(`Advanced: ${advSettings.join(', ')}`, 'info');
            }

            try {
                // Initialize FFmpeg if needed
                await getFFmpeg();

                let blob;

                // Handle different conversion methods
                if (presetKey === 'waveform') {
                    // Get waveform-specific options
                    const waveformFps = parseInt(document.getElementById('waveformFps').value);
                    const barWidth = parseInt(document.getElementById('barWidth').value);

                    // Use waveform visualization
                    log('Generating waveform frames...', 'info');
                    const { frames, duration, fps } = await generateWaveformFrames(audioFile, {
                        backgroundImage: imageFile,
                        waveformColor: '#00bfff',
                        playheadColor: '#ffffff',
                        fps: waveformFps,
                        barWidth: barWidth
                    });
                    log(`Generated ${frames.length} frames at ${fps} fps`, 'info');

                    log('Creating video from frames...', 'info');
                    const audioExt = getAudioExt();
                    blob = await createVideoFromFrames(frames, audioFile, fps, audioExt);
                } else if (presetKey === 'twoPass') {
                    blob = await runTwoPassConversion(audioFile, imageFile, getAudioExt());
                } else {
                    blob = await runConversion(preset, audioFile, imageFile, getAudioExt());
                }

                const duration = ((Date.now() - startTime) / 1000).toFixed(2);
                const sizeKB = (blob.size / 1024).toFixed(2);

                // Get video duration by loading it into a video element
                const url = URL.createObjectURL(blob);
                const video = document.createElement('video');
                video.src = url;

                // Wait for metadata to load to get duration
                await new Promise((resolve) => {
                    video.addEventListener('loadedmetadata', () => {
                        resolve();
                    });
                    video.load();
                });

                const videoDuration = video.duration.toFixed(2);

                // Store result
                results[presetKey] = {
                    success: true,
                    size: blob.size,
                    sizeKB,
                    duration,
                    videoDuration,
                    blob
                };

                // Update UI
                card.className = 'preset-card success';
                button.innerHTML = 'Test This Preset';
                button.disabled = false;

                resultDiv.innerHTML = `
                    <div class="stats">
                        <span class="stat">‚úÖ ${sizeKB} KB</span>
                        <span class="stat">üé¨ ${videoDuration}s video</span>
                        <span class="stat">‚è±Ô∏è ${duration}s to generate</span>
                    </div>
                    <video class="preset-video" src="${url}" controls></video>
                `;

                log(`‚úÖ ${preset.name} succeeded: ${sizeKB} KB, ${videoDuration}s video, generated in ${duration}s`, 'success');

            } catch (error) {
                const duration = ((Date.now() - startTime) / 1000).toFixed(2);
                const errorMsg = error?.message || String(error) || 'Unknown error';

                results[presetKey] = {
                    success: false,
                    error: errorMsg,
                    duration
                };

                card.className = 'preset-card error';
                button.innerHTML = 'Test This Preset';
                button.disabled = false;

                resultDiv.innerHTML = `<div style="color: #ff6666;">‚ùå ${errorMsg}</div>`;
                log(`‚ùå ${preset.name} failed: ${errorMsg}`, 'error');
            }

            updateComparisonTable();
        };

        // Run all tests
        window.runAllTests = async function() {
            if (!audioFile) {
                alert('Please select an audio file first');
                return;
            }

            log('\nüöÄ Running all viable presets...', 'warning');

            const viablePresets = ['production', 'balanced', 'compressed', 'waveform'];
            for (const key of viablePresets) {
                await runPreset(key);
            }

            log('‚úÖ All tests complete!', 'success');
        };

        // Clear results
        window.clearResults = function() {
            const viablePresets = ['production', 'balanced', 'compressed', 'waveform'];
            viablePresets.forEach(key => {
                const card = document.getElementById(`preset-${key}`);
                if (card) {
                    card.className = 'preset-card';
                    const resultDiv = document.getElementById(`result-${key}`);
                    if (resultDiv) resultDiv.innerHTML = '';
                }
            });

            Object.keys(results).forEach(key => delete results[key]);
            document.getElementById('comparisonTable').style.display = 'none';
            logEl.innerHTML = '';
            log('Results cleared', 'info');
        };

        // Update comparison table
        function updateComparisonTable() {
            const hasResults = Object.keys(results).length > 0;
            document.getElementById('comparisonTable').style.display = hasResults ? 'block' : 'none';

            if (!hasResults) return;

            const tbody = document.getElementById('resultsBody');
            tbody.innerHTML = '';

            // Find best/worst for highlighting
            const successfulResults = Object.entries(results).filter(([_, r]) => r.success);
            const sizes = successfulResults.map(([_, r]) => r.size);
            const times = successfulResults.map(([_, r]) => parseFloat(r.duration));
            const minSize = Math.min(...sizes);
            const maxSize = Math.max(...sizes);
            const minTime = Math.min(...times);
            const maxTime = Math.max(...times);

            Object.entries(results).forEach(([key, result]) => {
                const preset = conversionPresets[key];
                const row = tbody.insertRow();

                row.insertCell().textContent = preset.name;

                const sizeCell = row.insertCell();
                if (result.success) {
                    sizeCell.textContent = `${result.sizeKB} KB`;
                    if (result.size === minSize) sizeCell.className = 'best';
                    if (result.size === maxSize) sizeCell.className = 'worst';
                } else {
                    sizeCell.textContent = '-';
                }

                const videoDurationCell = row.insertCell();
                videoDurationCell.textContent = result.videoDuration ? `${result.videoDuration}s` : '-';

                const timeCell = row.insertCell();
                timeCell.textContent = `${result.duration}s`;
                if (result.success) {
                    const time = parseFloat(result.duration);
                    if (time === minTime) timeCell.className = 'best';
                    if (time === maxTime) timeCell.className = 'worst';
                }

                const statusCell = row.insertCell();
                statusCell.textContent = result.success ? '‚úÖ' : '‚ùå';
                statusCell.style.color = result.success ? '#00ff00' : '#ff6666';
            });
        }

        // Download comparison as CSV
        window.downloadComparison = function() {
            if (Object.keys(results).length === 0) {
                alert('No results to download');
                return;
            }

            let csv = 'Preset,File Size (KB),Video Duration (s),Generation Time (s),Status\n';
            Object.entries(results).forEach(([key, result]) => {
                const preset = conversionPresets[key];
                csv += `"${preset.name}",${result.sizeKB || '-'},${result.videoDuration || '-'},${result.duration},${result.success ? 'Success' : 'Failed'}\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ffmpeg-comparison-${Date.now()}.csv`;
            a.click();
        };

        // Helper to get audio extension
        function getAudioExt() {
            return audioFile ? audioFile.name.split('.').pop()?.toLowerCase() || 'mp3' : 'mp3';
        }

        // Add event listeners to controls to update status
        ['framerate', 'gopSize', 'tuneStillImage', 'threads', 'waveformFps', 'barWidth'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('change', updateSettingsStatus);
                el.addEventListener('input', updateSettingsStatus);
            }
        });

        // Initialize
        initializeControls();
        updateSettingsStatus();
        createPresetCards();
        log('Ready! Select files and test different presets.', 'info');
        log(`Production defaults loaded: framerate=${STILL_IMAGE_SETTINGS.framerate}, fps=${WAVEFORM_SETTINGS.fps}`, 'info');

        // Try loading default test file
        fetch('/zoom.m4a')
            .then(response => response.blob())
            .then(blob => {
                audioFile = new File([blob], 'zoom.m4a', { type: 'audio/m4a' });
                document.getElementById('audioFile').files = new DataTransfer().files;
                log('Loaded default test file: zoom.m4a', 'success');
            })
            .catch(() => {
                log('No default test file found', 'warning');
            });

        })(); // End of IIFE
    </script>
</body>
</html>